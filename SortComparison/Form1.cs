using System.Windows.Forms;
using System;

namespace SortComparison
{
    public partial class Form1 : Form
    {
        // Массив текстовых описаний алгоритмов сортировки
        string[] textarr = new string[]
        {
            "Алгоритм сортировки пузырьком:\n" +
            "Представьте, что у вас есть стакан с водой, в котором плавают пузырьки воздуха. Маленькие пузырьки медленно поднимаются наверх, а большие остаются внизу. " +
            "Точно так же работает этот алгоритм: мы проходим по массиву несколько раз, сравнивая соседние числа. Если два числа стоят в неправильном порядке (например, большее число перед меньшим), мы меняем их местами. " +
            "Мы повторяем это снова и снова, пока все числа не окажутся на своих правильных местах.\n" +
            "Пример: [5, 3, 8, 6] → [3, 5, 6, 8].\n" +
            "Это как будто пузырьки воздуха поднимаются вверх, а тяжелые камни опускаются вниз.",

            "Двунаправленная пузырьковая сортировка (шейкерная сортировка):\n" +
            "Эта сортировка похожа на пузырьковую, но она работает в обе стороны. Представьте, что вы двигаетесь вдоль ряда книг на полке. Сначала вы идете слева направо, проверяя, правильно ли стоят книги. " +
            "Если книги стоят неправильно, вы меняете их местами. Затем вы идете справа налево и делаете то же самое. Так вы быстрее перемещаете самые маленькие и самые большие книги на свои места.\n" +
            "Пример: [5, 3, 8, 6] → [3, 5, 6, 8].\n" +
            "Это как если бы вы раскладывали книги, двигаясь туда-сюда по полке.",

            "Карманная сортировка (Bucket Sort):\n" +
            "Представьте, что у вас есть коробка с разноцветными шариками. Вы хотите отсортировать их по цветам. Для этого вы берете несколько корзинок, каждая из которых предназначена для одного цвета. " +
            "Вы кладете красные шарики в одну корзинку, синие — в другую, зеленые — в третью и так далее. Затем вы собираете шарики обратно, начиная с первой корзинки. Теперь все шарики отсортированы по цветам.\n" +
            "Так же работает карманная сортировка: числа распределяются по 'корзинкам', а затем собираются в правильном порядке.\n" +
            "Пример: [3, 1, 4, 2] → [1, 2, 3, 4].",

            "Гребенчатая сортировка (Comb Sort):\n" +
            "Представьте, что вы расчесываете волосы гребнем. Сначала вы используете большой гребень, чтобы разделить волосы на большие пряди. Затем вы берете меньший гребень и расчесываете волосы более тщательно. " +
            "Так же работает гребенчатая сортировка: сначала мы сравниваем числа, которые находятся далеко друг от друга (большой шаг), а затем постепенно уменьшаем шаг, чтобы сравнить числа, которые ближе друг к другу.\n" +
            "Пример: [9, 3, 7, 5] → [3, 5, 7, 9].\n" +
            "Это как если бы вы расчесывали массив чисел, начиная с широких прядей и заканчивая тонкими.",

            "Циклическая сортировка (Cycle Sort):\n" +
            "Представьте, что у вас есть набор игрушек, и каждая игрушка должна стоять на своем месте на полке. Циклическая сортировка работает так: она находит игрушку, которая стоит не на своем месте, и перемещает её на правильное место. " +
            "Затем она берет игрушку, которая была на этом месте, и тоже перемещает её на свое место. Этот процесс продолжается, пока все игрушки не окажутся на своих местах.\n" +
            "Пример: [4, 2, 3, 1] → [1, 2, 3, 4].\n" +
            "Это как собирать пазл: каждая деталь сразу идет на свое место.",

            "Гномья сортировка (Gnome Sort):\n" +
            "Представьте, что у вас есть гном, который ходит по массиву чисел. Гном проверяет, правильно ли стоят два соседних числа. Если они стоят неправильно, он меняет их местами и делает шаг назад. " +
            "Если порядок правильный, он делает шаг вперед. Так он обходит весь массив до конца.\n" +
            "Пример: [5, 3, 8, 6] → [3, 5, 6, 8].\n" +
            "Это как будто гном исправляет ошибки шаг за шагом.",

            "Пирамидальная сортировка (Heap Sort):\n" +
            "Представьте, что у вас есть пирамида из кубиков, где самый большой кубик всегда находится сверху. Сначала мы строим такую пирамиду из чисел. Затем берем самый большой кубик (число) и кладем его в конец массива. " +
            "После этого мы перестраиваем пирамиду, чтобы найти следующий самый большой кубик. Мы повторяем этот процесс, пока вся пирамида не закончится.\n" +
            "Пример: [9, 3, 7, 5] → [3, 5, 7, 9].\n" +
            "Это как если бы вы строили пирамиду из кубиков и каждый раз доставали верхний кубик.",

            "Сортировка вставками (Insertion Sort):\n" +
            "Представьте, что вы сортируете карты в руке. Вы берете одну карту и вставляете её на правильное место среди уже отсортированных карт. Затем берете следующую карту и снова вставляете её на правильное место. " +
            "Таким же образом мы берем каждый элемент массива и вставляем его в правильное место среди уже отсортированных элементов.\n" +
            "Пример: [4, 2, 3, 1] → [1, 2, 3, 4].\n" +
            "Это как будто вы аккуратно раскладываете карты в руке.",

            "Сортировка слиянием (Merge Sort):\n" +
            "Представьте, что у вас есть колода карт, и вы хотите её отсортировать. Сначала вы делите колоду на две части. Затем каждую часть сортируете отдельно. После этого вы аккуратно соединяете две отсортированные части вместе, чтобы получить одну отсортированную колоду. " +
            "Так работает эта сортировка: массив делится пополам, каждая половина сортируется, а затем они сливаются в один отсортированный массив.\n" +
            "Пример: [7, 3, 5, 2] → [2, 3, 5, 7].\n" +
            "Это как если бы вы разделили книжную полку на две части, отсортировали каждую часть, а потом соединили их вместе.",

            "Нечётно-чётная сортировка (Odd-Even Sort):\n" +
            "Представьте, что у вас есть очередь людей, и вы хотите их рассортировать по росту. Сначала вы проверяете всех людей, которые стоят на нечетных позициях (первый, третий, пятый и т.д.). " +
            "Если человек выше того, кто стоит перед ним, вы меняете их местами. Затем вы проверяете всех людей на четных позициях (второй, четвертый, шестой и т.д.) и делаете то же самое. " +
            "Процесс повторяется до тех пор, пока все люди не окажутся в правильном порядке.\n" +
            "Пример: [5, 3, 8, 6] → [3, 5, 6, 8].\n" +
            "Это как если бы вы проверяли людей в очереди, двигаясь по парам.",

            "Быстрая сортировка (Quick Sort):\n" +
            "Представьте, что у вас есть группа людей, и вы хотите их рассортировать по росту. Вы выбираете одного человека (обычно среднего) и просите всех, кто ниже его ростом, встать слева, а тех, кто выше, — справа. " +
            "Затем вы повторяете это для каждой группы: сначала для левой, потом для правой. В итоге все люди (числа) оказываются в правильном порядке.\n" +
            "Пример: [9, 3, 7, 5] → [3, 5, 7, 9].\n" +
            "Это как если бы вы делили группу людей на подгруппы, пока каждая подгруппа не станет идеально отсортированной.",

            "Быстрая сортировка с пузырьковой сортировкой:\n" +
            "Это комбинация двух методов. Сначала мы используем быструю сортировку, чтобы разделить массив на маленькие части. Затем, когда части становятся достаточно маленькими, мы применяем пузырьковую сортировку, чтобы завершить работу с этими частями. " +
            "Так мы получаем быстрый и эффективный способ сортировки.\n" +
            "Пример: [9, 3, 7, 5] → [3, 5, 7, 9].\n" +
            "Это как если бы вы сначала разделили задачу на маленькие части, а потом решили каждую часть по отдельности.",

            "Сортировка выбором (Selection Sort):\n" +
            "Представьте, что у вас есть коробка с карандашами разной длины, и вы хотите их рассортировать по длине. Сначала вы ищете самый короткий карандаш и кладете его на первое место. " +
            "Затем вы ищете следующий самый короткий карандаш и кладете его на второе место. Так продолжается до тех пор, пока все карандаши не окажутся в правильном порядке.\n" +
            "Пример: [4, 2, 3, 1] → [1, 2, 3, 4].\n" +
            "Это как будто вы выбираете самые маленькие предметы и ставите их на свои места.",

            "Сортировка Шелла (Shell Sort):\n" +
            "Эта сортировка похожа на сортировку вставками, но сначала мы сортируем числа, которые находятся далеко друг от друга, а затем постепенно уменьшаем расстояние между ними. " +
            "Представьте, что вы сначала сортируете каждую пятую книгу на полке, затем каждую третью, а в конце каждую соседнюю. Так мы быстрее добиваемся правильного порядка.\n" +
            "Пример: [9, 3, 7, 5] → [3, 5, 7, 9].\n" +
            "Это как если бы вы сначала раскладывали книги через одну, а потом уточняли их положение.",

            "Сортировка методом голубятни (Pigeonhole Sort):\n" +
            "Представьте, что у вас есть ячейки для каждого возможного числа. Вы раскладываете числа по ячейкам, а затем собираете их обратно в правильном порядке. " +
            "Этот метод особенно хорош для сортировки целых чисел, потому что он быстро раскладывает числа по ячейкам и собирает их обратно.\n" +
            "Пример: [3, 1, 4, 2] → [1, 2, 3, 4].\n" +
            "Это как если бы вы раскладывали монеты по копилкам, а потом собирали их обратно."
        };


        public Form1()
        {
            InitializeComponent();
            label1.Text = "     " + textarr[0]; // Начальный текст
        }

        private void button1_Click(object sender, EventArgs e)
        {
            frmMain newForm = new frmMain(this);
            this.Hide();
            newForm.Show();
        }

        private int currentIndex = 0;

        private void button2_Click(object sender, EventArgs e)
        {
            if (currentIndex > 0)
            {
                currentIndex--;
                label1.Text = "     " + textarr[currentIndex];
            }
            else
            {

                currentIndex = textarr.Length - 1;
                label1.Text = "     " + textarr[currentIndex];
            }
        }

        private void button3_Click(object sender, EventArgs e)
        {
            if (currentIndex < textarr.Length - 1)
            {
                currentIndex++;
                label1.Text = "     " + textarr[currentIndex];
            }
            else
            {
                currentIndex = 0;
                label1.Text = "     " + textarr[currentIndex];
            }
        }
    }
}